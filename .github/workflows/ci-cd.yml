name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read
  id-token: write

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  TERRAFORM_VERSION: 1.7.5
  NODE_VERSION: '20'
  CHECK_FAIL_ON: 'NONE'

jobs:
  static-analysis:
    name: Static Analysis
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Checkov
        run: pip install checkov

      - name: Install backend dependencies
        if: ${{ hashFiles('backend/package.json') != '' }}
        working-directory: backend
        run: |
          if [ -f package-lock.json ]; then
            npm ci
          else
            npm install
          fi

      - name: Install frontend dependencies
        if: ${{ hashFiles('frontend/package.json') != '' }}
        working-directory: frontend
        run: |
          if [ -f package-lock.json ]; then
            npm ci
          else
            npm install
          fi

      - name: Run Checkov on Terraform
        run: |
          if [ -d terraform ]; then
            set +e
            checkov -d terraform --framework terraform --output cli --output json --output-file-path .
            status=$?
            if [ -f results_json.json ]; then
              mv results_json.json checkov_results.json
            else
              echo '{"summary":{"failed":0,"passed":0,"skipped":0},"results":{"failed_checks":[]}}' > checkov_results.json
            fi
            if [ "${{ env.CHECK_FAIL_ON }}" = "FAILURE" ] && [ $status -ne 0 ]; then
              echo "Checkov detected failures" >&2
              cat checkov_results.json
              exit $status
            fi
          else
            echo '{"summary":{"failed":0,"passed":0,"skipped":0},"results":{"failed_checks":[]}}' > checkov_results.json
          fi

      - name: Upload Checkov report
        uses: actions/upload-artifact@v4
        with:
          name: static-analysis-results
          path: checkov_results.json

  frontend-build:
    name: Frontend Build
    runs-on: ubuntu-latest
    needs: static-analysis
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: frontend
        run: |
          if [ -f package-lock.json ]; then
            npm ci
          else
            npm install
          fi

      - name: Build frontend
        working-directory: frontend
        run: npm run build

      - name: List dist contents
        working-directory: frontend
        run: |
          ls -la dist
          ls -la dist/assets || echo "Assets directory not found!"

      - name: Upload frontend artifact
        uses: actions/upload-artifact@v4
        with:
          name: frontend-dist
          path: frontend/dist

  create-lambda-bucket:
    name: Ensure Lambda S3 Bucket
    runs-on: ubuntu-latest
    needs: [static-analysis, frontend-build]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Ensure Lambda artifact bucket exists
        id: bucket
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          BUCKET="transaction-simulator-lambda-code-${ACCOUNT_ID}-${AWS_REGION}"
          aws s3 mb "s3://${BUCKET}" 2>/dev/null || echo "Bucket already exists"
          echo "bucket=${BUCKET}" >> "$GITHUB_OUTPUT"

    outputs:
      bucket: ${{ steps.bucket.outputs.bucket }}

  lambda-package:
    name: Package Lambda Function
    runs-on: ubuntu-latest
    needs: create-lambda-bucket
    outputs:
      lambda-bucket: ${{ steps.lambda-info.outputs.lambda_bucket }}
      lambda-key: ${{ steps.lambda-info.outputs.lambda_key }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: lambda/package-lock.json

      - name: Install Lambda dependencies
        working-directory: lambda
        run: |
          if [ -f package-lock.json ]; then
            npm ci
          else
            npm install
          fi

      - name: Create Lambda package
        run: zip -r lambda.zip lambda

      - name: Upload Lambda package to S3
        id: lambda-info
        env:
          BUCKET: ${{ needs.create-lambda-bucket.outputs.bucket }}
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          BUCKET_NAME="${BUCKET:-transaction-simulator-lambda-code-${ACCOUNT_ID}-${AWS_REGION}}"
          KEY="lambda-packages/lambda-${GITHUB_SHA}.zip"
          aws s3 cp lambda.zip "s3://${BUCKET_NAME}/${KEY}" --metadata-directive REPLACE --acl bucket-owner-full-control --sse AES256
          echo "LAMBDA_S3_BUCKET=${BUCKET_NAME}" > build.env
          echo "LAMBDA_S3_KEY=${KEY}" >> build.env
          echo "lambda_bucket=${BUCKET_NAME}" >> "$GITHUB_OUTPUT"
          echo "lambda_key=${KEY}" >> "$GITHUB_OUTPUT"
          echo "account_id=${ACCOUNT_ID}" >> "$GITHUB_OUTPUT"

      - name: Upload Lambda artifacts
        uses: actions/upload-artifact@v4
        with:
          name: lambda-artifacts
          path: |
            lambda.zip
            build.env

  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    needs: lambda-package
    outputs:
      plan-path: tfplan
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Download Lambda metadata
        uses: actions/download-artifact@v4
        with:
          name: lambda-artifacts
          path: artifacts/lambda

      - name: Load Lambda S3 location
        id: load-lambda
        run: |
          set -euo pipefail
          source artifacts/lambda/build.env
          echo "bucket=$LAMBDA_S3_BUCKET" >> "$GITHUB_OUTPUT"
          echo "key=$LAMBDA_S3_KEY" >> "$GITHUB_OUTPUT"

      - name: Terraform init
        working-directory: terraform
        run: terraform init -input=false -reconfigure

      - name: Terraform plan
        working-directory: terraform
        env:
          LAMBDA_S3_BUCKET: ${{ steps.load-lambda.outputs.bucket }}
          LAMBDA_S3_KEY: ${{ steps.load-lambda.outputs.key }}
        run: terraform plan -var="lambda_s3_bucket=${LAMBDA_S3_BUCKET}" -var="lambda_s3_key=${LAMBDA_S3_KEY}" -out=tfplan

      - name: Upload Terraform plan
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan
          path: terraform/tfplan

  manual-approval:
    name: Await Manual Approval
    runs-on: ubuntu-latest
    needs: terraform-plan
    environment:
      name: production
    steps:
      - name: Approval required
        run: |
          echo "This job requires approval in the production environment before continuing."

  terraform-apply:
    name: Terraform Apply
    runs-on: ubuntu-latest
    needs: manual-approval
    outputs:
      outputs-file: terraform_outputs.json
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Download Lambda metadata
        uses: actions/download-artifact@v4
        with:
          name: lambda-artifacts
          path: artifacts/lambda

      - name: Download Terraform plan
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan
          path: artifacts/terraform

      - name: Apply Terraform plan
        working-directory: terraform
        env:
          TF_CLI_ARGS: -input=false
        run: terraform apply -auto-approve ../artifacts/terraform/tfplan

      - name: Capture Terraform outputs
        working-directory: terraform
        run: terraform output -json > ../terraform_outputs.json

      - name: Upload Terraform outputs
        uses: actions/upload-artifact@v4
        with:
          name: terraform-outputs
          path: terraform_outputs.json

  lambda-canary-deployment:
    name: Lambda Canary Deployment
    runs-on: ubuntu-latest
    needs: [terraform-apply, lambda-package]
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Trigger CodeDeploy deployment
        env:
          APPLICATION_NAME: ${{ secrets.CODEDEPLOY_APPLICATION_NAME }}
          DEPLOYMENT_GROUP: ${{ secrets.CODEDEPLOY_DEPLOYMENT_GROUP }}
          LAMBDA_BUCKET: ${{ needs.lambda-package.outputs['lambda-bucket'] }}
          LAMBDA_KEY: ${{ needs.lambda-package.outputs['lambda-key'] }}
        run: |
          if [ -z "$APPLICATION_NAME" ] || [ -z "$DEPLOYMENT_GROUP" ]; then
            echo "CodeDeploy application or deployment group secrets are not configured." >&2
            exit 1
          fi
          DEPLOYMENT_ID=$(aws deploy create-deployment \
            --application-name "$APPLICATION_NAME" \
            --deployment-group-name "$DEPLOYMENT_GROUP" \
            --s3-location bucket=$LAMBDA_BUCKET,key=$LAMBDA_KEY,bundleType=zip \
            --query deploymentId --output text)
          echo "Started deployment $DEPLOYMENT_ID"
          aws deploy wait deployment-successful --deployment-id "$DEPLOYMENT_ID"
          echo "Deployment $DEPLOYMENT_ID completed successfully."

  smoke-tests:
    name: Smoke Tests
    runs-on: ubuntu-latest
    needs: lambda-canary-deployment
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Download Terraform outputs
        uses: actions/download-artifact@v4
        with:
          name: terraform-outputs
          path: artifacts

      - name: Install curl and jq
        run: sudo apt-get update -y && sudo apt-get install -y curl jq

      - name: Run smoke tests
        env:
          TERRAFORM_OUTPUTS: artifacts/terraform_outputs.json
        run: |
          API_URL=$(jq -r '.api_gateway_invoke_url.value' "$TERRAFORM_OUTPUTS")
          FRONTEND_URL=$(jq -r '.frontend_website_url.value' "$TERRAFORM_OUTPUTS")
          if [ -z "$API_URL" ]; then
            echo "ERROR: API_URL is empty." >&2
            exit 1
          fi
          if [ -z "$FRONTEND_URL" ]; then
            echo "ERROR: FRONTEND_URL is empty." >&2
            exit 1
          fi
          curl -v --fail "$API_URL/api/login"
          curl -v --fail "$FRONTEND_URL"
          echo "Smoke tests completed successfully."
